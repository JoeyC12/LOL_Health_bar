# LoL 血量实时监控系统

一个基于计算机视觉和 OCR 技术的英雄联盟血量实时监控工具，能够自动识别游戏中的血量信息并实时显示。

## 功能特性

- 🎯 **实时监控**：每秒更新血量信息
- 📊 **双重显示**：显示具体血量（分子/分母）和百分比
- 🚀 **高性能**：优化后的算法，快速响应
- 💾 **智能缓存**：自动缓存检测结果，提升速度
- 🎨 **悬浮窗口**：半透明悬浮 HUD，不遮挡游戏画面

## 算法流程

### 整体架构

```
截屏 → 边缘检测定位血量条 → OCR识别文本 → 解析血量 → 显示结果
```

### 详细流程

#### 1. **截屏阶段** (`watch_hp.py`)
- 使用 `PIL.ImageGrab` 截取右侧副屏（1920x1080）
- 直接转换为 numpy 数组，避免文件 IO

#### 2. **血量条定位** (`detect_hp_bar_by_edge()`)

**Step 0: ROI 提取**
- 提取屏幕底部中央区域（高度 4/5 到 1，宽度 1/4 到 3/4）
- 这是血量条最可能出现的位置

**Step 1: 灰度化与模糊**
- 转换为灰度图
- 高斯模糊（5x5）降噪

**Step 2: 边缘检测**
- 使用 Canny 边缘检测（阈值 50-150）
- 提取血量条的边缘特征

**Step 3: 形态学处理**
- 使用 15x3 矩形核进行闭运算
- 连接断开的边缘，形成完整的轮廓

**Step 4: 轮廓筛选**
- 查找所有轮廓
- 筛选条件：宽度 ≥ 40，高度 ≥ 4
- 选择最宽的轮廓作为血量条（通常血量条是最宽的）

#### 3. **OCR 识别** (`extract_health_text_from_roi()`)
- 使用 PaddleOCR 识别血量文本
- 查找包含 `/` 的文本（如 "1234/5678"）
- 提取当前血量和最大血量

#### 4. **缓存机制**
- **首次运行**：完整边缘检测 → OCR → 保存 bbox
- **后续运行**：直接使用缓存的 bbox → OCR（跳过边缘检测）
- **失败回退**：缓存失败时自动删除 bbox.txt，下次运行完整检测

#### 5. **结果显示**
- 计算血量百分比：`health_rate = cur / max_hp`
- 更新 UI 显示：具体血量和百分比

## 性能优化项目

### 1. **OCR 模型复用** ⚡ (最大优化)
- **问题**：每次调用都创建新的 `PaddleOCR()` 实例，初始化耗时 ~500ms
- **优化**：使用全局单例模式，只初始化一次
- **效果**：首次 ~500ms，后续 0ms
- **代码位置**：`get_ocr_instance()` 函数

### 2. **减少文件 IO** 💾
- **截屏**：不再保存 `screen.png`，直接传 numpy 数组
- **调试图片**：只在 `debug=True` 时保存（step0-4、hp_result_with_text.png）
- **step4 图片**：非 debug 模式从内存提取 ROI，不写文件
- **失败 ROI**：只在 debug 模式保存 `hp_ocr_failed_roi.png`
- **效果**：减少 3-5 次文件读写操作

### 3. **优化图像处理** 🖼️
- 减少不必要的 `.copy()` 操作
- 使用数组视图而非复制（在需要时再 copy）
- 优化 ROI 提取逻辑

### 4. **减少日志输出** 📝
- 非 debug 模式减少 print 输出
- 移除不必要的调试信息
- 只在关键节点输出日志

### 5. **智能缓存机制** 🧠
- 使用缓存的 bbox 时跳过边缘检测（最耗时的步骤）
- 缓存失败自动回退到完整检测
- 只保存 bbox 坐标，不保存其他冗余信息

### 6. **OCR 配置优化** ⚙️
- `use_angle_cls=False`：禁用角度分类，提升速度
- `show_log=False`：关闭日志输出
- `use_gpu=False`：使用 CPU（避免 GPU 初始化开销）

## 性能对比

| 操作 | 优化前 | 优化后 | 提升 |
|------|--------|--------|------|
| OCR 初始化 | 每次 ~500ms | 首次 ~500ms | **100%** |
| 文件 IO | 3-5 次读写 | 0-1 次读写 | **80%** |
| 完整检测 | ~800ms | ~600ms | **25%** |
| 缓存检测 | N/A | ~200ms | **新增** |
| **总体速度** | **~1.0s** | **~0.3-0.5s** | **50-70%** |

## 文件结构

```
LOL_Health_bar/
├── lol.py              # 核心算法（边缘检测 + OCR）
├── watch_hp.py         # 实时监控主程序
├── bbox.txt            # 缓存的 bbox 坐标
├── screen.png          # 截屏文件（可选）
├── hp_result_with_text.png  # 可视化结果（debug模式）
└── hp_edge_steps/      # 调试图片目录（debug模式）
    ├── step0_bottom_center_roi.png
    ├── step1_gray.png
    ├── step2_edges.png
    ├── step3_edges_closed.png
    ├── step4_all_candidates.png
    └── step4_final_bbox.png
```

## 使用方法

### 安装依赖

```bash
pip install opencv-python pillow paddleocr numpy
```

### 运行程序

```bash
python watch_hp.py
```

### 调试模式

修改 `watch_hp.py` 中的 `debug=True`，会保存所有中间步骤的图片。

## 技术栈

- **计算机视觉**：OpenCV（边缘检测、形态学处理）
- **OCR**：PaddleOCR（文本识别）
- **图像处理**：PIL、NumPy
- **UI**：Tkinter（悬浮窗口）

## 注意事项

1. **屏幕分辨率**：代码中硬编码了副屏尺寸（1920x1080），如需修改请调整 `watch_hp.py` 中的参数
2. **bbox 缓存**：如果游戏窗口位置变化，可能需要删除 `bbox.txt` 重新检测
3. **性能**：首次运行会较慢（OCR 初始化），后续运行会更快

## 未来优化方向

- [ ] 使用更小的 OCR 模型（MobileNet）
- [ ] 多线程并行处理
- [ ] 降低图像分辨率（在保证识别率的前提下）
- [ ] GPU 加速（如果有独立显卡）
- [ ] 自适应 bbox 更新机制

